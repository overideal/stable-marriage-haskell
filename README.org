This is an implementation of the [[https://en.wikipedia.org/wiki/Stable_matching_problem][stable marriage problem]] (stable matching problem)
and the [[https://en.wikipedia.org/wiki/Gale%E2%80%93Shapley_algorithm][Gale-Shapley algorithm]] (deferred acceptance algorithm) in Haskell.

* Features
** Deferred Acceptance Algorithm
After importing the library, it can be used as follows:
#+BEGIN_SRC haskell
import StableMarriage
prefs :: PrefProfile String String
prefs = listToPrefProfile
  ([("m1", ["w1", "w3", "w4", "w2"]), ("m2", ["w1", "w3", "w2", "w4"]),
     ("m3", ["w2", "w1", "w3", "w4"]), ("m4" , ["w2", "w4" , "w1", "w3"])],
   [("w1", ["m4", "m3", "m1", "m2"]), ("w2", ["m2", "m4", "m1", "m3"]),
     ("w3", ["m4", "m1", "m2", "m3"]), ("w4", ["m3", "m2", "m1", "m4"])])

prefs2 :: PrefProfile Int Int
prefs2 = listToPrefProfile
  ([(0, [7,5,6,4]), (1, [5,4,6,7]),
     (2, [4, 5, 6, 7]), (3, [4, 5, 6, 7])],
   [(4, [0, 1, 2, 3]), (5, [0, 1, 2, 3]),
     (6, [0, 1, 2, 3]), (7, [0, 1, 2, 3])])

deferredAcceptanceAlg prefs
deferredAcceptanceAlgWomen prefs
deferredAcceptanceAlg prefs2
#+END_SRC

This demonstrates the main algorithms, namely =deferredAcceptanceAlg= and =deferredAcceptanceAlgWomen=.
The latter has the second entries ("women") propose instead of the first entries ("men").

** Checks
Given a matching, it can be checked for stability using =isStableMatching=.
Use =hasFavorite= to check if some person obtained their favorite partner in the matching.

** Exhaustive Search
For exhaustive searches (e.g. for examples and counterexamples), we provide:
- =computeMatchings= to compute matchings for all preference profiles of a certain size,
  up to permutations.
- =computeAllMatchings= to compute matchings for all preference profiles of a certain size,
  ignoring permutations.
- =computeUniqueMatchings= to compute all unique matchings, up to permutations.
  Note that a matching is unique if and only if it is the result of the
  deferred acceptance algorithm both when men and when women propose.
  This is because the produced matchings are optimal for the men and women, respectively.
- =computeAllUniqueMatchings= to compute all unique matchings, ignoring permutations.

Due to the exponential runtime, these are only useful for small inputs.

** Converter
Finally, for convenience a function =listToPrefProfile= is provided in order
to convert a pair of association lists to preference profiles.

* Example Usages
Using this library, it is straightforward to find small examples and counterexamples.

** Unique matchings
How many unique matchings are there?
#+BEGIN_SRC haskell
n = 3
num_matchings = length . computeAllMatchings $ n
num_unique_matchings = length . computeAllUniqueMatchings $ n
#+END_SRC
We see that for n = 2, 14/16 = 87.5% of all matchings are unique.
Similarly, for n = 3, 34080/46656 \approx 73% of all matchings are unique.

If we only care about preference profiles up to permutations,
then for n = 3, 3380/4536 \approx 74.5% of all matchings are unique.
#+BEGIN_SRC haskell
n = 3
num_matchings = length . computeMatchings $ n
num_unique_matchings = length . computeUniqueMatchings $ n
#+END_SRC

Using the code (or by inspection)
#+BEGIN_SRC haskell
computeMatchings 2 \\ computeUniqueMatchings 2
#+END_SRC
the unique (up to permutation) preference profile giving rise to different matchings is
| m1 | m2 | w1 | w2 |
|----+----+----+----|
| w1 | w2 | m2 | m1 |
| w2 | w1 | m1 | m2 |

** Does someone always get their first choice?
Does any pair of preference profiles always admit a stable matching
where at least one person gets their first choice?

The answer is no; a counter example was already given by Gale and Shapley
in their original paper /College admissions and the stability of marriage/ from 1962.
In our syntax, the example reads:
#+BEGIN_SRC haskell
prefs :: PrefProfile String String
prefs = listToPrefProfile
  ([("m1", ["w1", "w2", "w3", "w4"]), ("m2", ["w1", "w4", "w3", "w2"]),
    ("m3", ["w2", "w1", "w3", "w4"]), ("m4" , ["w4", "w2" , "w3", "w1"])],
   [("w1", ["m4", "m3", "m1", "m2"]), ("w2", ["m2", "m4", "m1", "m3"]),
    ("w3", ["m4", "m1", "m2", "m3"]), ("w4", ["m3", "m2", "m1", "m4"])])
matching = deferredAcceptanceAlg prefs
hasFavorite prefs matching
#+END_SRC

There is no counter example for n=3 people per side.
#+BEGIN_SRC haskell
filter (not . uncurry hasFavorite) . computeMatchings $ 3
#+END_SRC

It is straightforward to find more matchings where no person gets their first choice
and we can even restrict to unique matchings:
#+BEGIN_SRC haskell
take 3 . filter (not . uncurry hasFavorite) . computeMatchings $ 4
take 3 . filter (not . uncurry hasFavorite) . computeUniqueMatchings $ 4
#+END_SRC

The second line produces the following examples,
which are only different in the preferences of the last woman:
#+BEGIN_SRC haskell
[((fromList [(1,[1,2,3,4]),(2,[4,3,1,2]),(3,[3,1,4,2]),(4,[3,1,4,2])],
   fromList [(1,[2,3,1,4]),(2,[2,1,3,4]),(3,[1,2,3,4]),(4,[3,4,2,1])]),
  fromList [(1,2),(2,3),(3,1),(4,4)]),
 ((fromList [(1,[1,2,3,4]),(2,[4,3,1,2]),(3,[3,1,4,2]),(4,[3,1,4,2])],
   fromList [(1,[2,3,1,4]),(2,[2,1,3,4]),(3,[1,2,3,4]),(4,[1,4,2,3])]),
  fromList [(1,2),(2,3),(3,1),(4,4)]),
 ((fromList [(1,[1,2,3,4]),(2,[4,3,1,2]),(3,[3,1,4,2]),(4,[3,1,4,2])],
   fromList [(1,[2,3,1,4]),(2,[2,1,3,4]),(3,[1,2,3,4]),(4,[1,4,3,2])]),
  fromList [(1,2),(2,3),(3,1),(4,4)])]
#+END_SRC


In table format, the first example reads as
| m1 | m2 | m3 | m4 | w1 | w2 | w3 | w4 |
|----+----+----+----+----+----+----+----|
| w1 | w4 | w3 | w3 | m2 | m2 | m1 | m3 |
| w2 | w3 | w1 | w1 | m3 | m1 | m2 | m4 |
| w3 | w1 | w4 | w4 | m1 | m3 | m3 | m2 |
| w4 | w2 | w2 | w2 | m4 | m4 | m4 | m1 |
and the produced matching is =(m1,w2),(m2,w3),(m3,w1),(m4,w4)=.
